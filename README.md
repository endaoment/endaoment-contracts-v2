# Endaoment Contracts V2

## Getting Started

This repo is built using [Foundry](https://github.com/gakonst/foundry)

1. If you don't have the rust toolchain installed, you can do so following the instructions [here](https://rustup.rs/). This will install `rustup`, `rustc`, and `cargo`
2. Next install `forge` with `cargo install --git https://github.com/gakonst/foundry --bin forge --locked`
3. Install dependencies with `forge update`

## Development

- Build contracts with `forge build`
- Run tests with `forge test` which defaults to 256 fuzz runs, or use `PROPTEST_CASES=n forge test` to run `n` fuzz runs (fuzzing in Foundry is done with the [proptest](https://altsysrq.github.io/proptest-book/proptest/tutorial/config.html) crate)

### Testing

Currently all tests are fuzz tests, where the fuzzer will generate a value between 0 and the max value of the specified type.
We often only want to fuzz values within a certain range, so we use the modulo operation to do that. For example,
to only test values between a range of 0 and 100, we could do:

```solidity
function testSomething(uint256 x) public {
  x = x % 101;
  // test here
}
```

The result of `x % 101` will always be between 0 and 100, so this trick has the effect of bringing the
value generated by the fuzzer down to our desired range.

Two alternate approaches to getting the desired range are:

- Specify another type such as `uint8`, but this gives you less control
- Return from your test early if the number is outside of the range, but early returns are basically wasted test runs

Note that combining the modulo approach with a smaller type is **not** recommended as it will bias the results.
For example, consider the case where we choose `uint8` and modify the result with `x = x % 200`.
The max initial value of `x` is 255, which is then wrapped to a range of 0 to 199.
As a result, any initial values from 0 to 199 are unchanged.
Values of 200-255 are wrapped to 0 to 55, making your fuzz tests more likely to test values between 0 and 55 than between 56 and 200.
When using a `uint256`, the size of this bias is so small that it's insignificant.
